# 11장 정리
1. 질의 함수와 변경 함수 분리하기
   '질의 함수(읽기 함수)는 모두 부수효과가 없어야 한다' -> 명령 - 질의 분리
   
   겉보기 부수효과라고 표현하는 이유는 캐싱과 같은 기능에서 객체의 상태를 변경하지만 객체 밖에서는 이를 관찰할 수 는 없다. 즉, 겉보디 부수효과가 없이 어떤 순서로 호출하든 모든 호출에 항상 똑같은 값을 반환할 뿐이다.

2. 함수 매개변수화하기

3. 플래그 인수 제거하기
   플래그 인수는 호출할 수 있는 함수들이 무엇이고 어떻게 호출해야 하는지를 이해하기 어려워진다.
   플래그 인수가 있으면 함수들의 기능 차이가 잘 드러나지 않는다.

4. 객체 통째로 넘기기
   레코드를 통째로 넘기면 변화에 대응하기 쉽다. 
   함수가 레코드 자체에 의존하기를 원치 않을 때는 이 리팩터링을 수행하지 않는데, 레코드와 함수가 서로 다른 모듈에 속한 상황이면 특히 더 그렇다.
      1. 객체로 넘길때에도 값을 묶거나, 분리해서 적절하게 넘겨라
      2. 다른 객체의 메서드를 호출하면서 호출하는 객체 자신이 가지고 있는 데이터 여러 개를 건네는 경우. 데이터 여러개 대신 객체 자신의 참조만 건네도록 수정해라(JS라면 this를 건넬것) 

5. 매개변수를 질의 함수로 바꾸기 CQRS
   매개변수 목록은 함수의 변동 요인을 모아놓은 곳이다. 즉, 함수의 동작에 변화를 줄 수 있는 일파적인 수단이다. 다른 코드와 마찬가지로 이 목록에서도 중복은 피하는 게 좋으며 짧을수록 이해하기 쉽다.
      피 호풀 함수가 스스호 쉽게 결정할 수 있는 값을 매개변수로 건네는 것도 일종의 중복이다.

      매개변수를 질의 함수로 바꾸지 말아야 할 상황도 있다. 매개변수를 제거하면 피호풀 함수에 원치 않는 의존성이 생길 때다. 
   - 주의 사항
         대상 함수가 참조 투명해야 한다는 것이다. 참조 투명이란 '함수에 똑같은 값을 건네 호출하면 항상 똑같이 동작한다'(멱등성같은뎅..)

6. 질의 함수를 매개변수로 바꾸기
   전역 변수를 참조한다든지 거북한 참조 발견시 여기에 속한다. 
   똑같은 값을 건네면 매번 똑같은 결과를 내는 함수는 다루기 쉽다. 이런 성질을 '참조 투명성'이라 한다.
      참조 투명하지 않은 원소에 접근하는 모든 함수는 참조 투명성을 잃게 되는데, 이 문제는 해당 원소를 매개변수로 바꾸면 해결된다.
   - 단점
      질의 함수를 매개변수로 바꾸면 어떤 값을 제공할지를 호출자가 알아내야 한다. 

7. 세터 제거하기
   
8. 생성자를 팩터리 함수로 바꾸기
   생성자는 언어마다 제약사항이 있다. 자바의 경우 반드시 그 생성자를 정의한 클래스의 인스턴스를 반환해야 한다. 
   서브클래스의 인스턴스나 프록시를 반환할 수 없다. 

    또, 생성자의 이름이 고정되어 기본 이름보다 더 적절한 이름이 있어도 사용할 수 없다. 

    게다가, 생성자를 호출하려면 특별한 연산자(like 'new')를 사용해야 해서 일반 함수가 오길 기대하는 자리에는 쓰기 어렵다.
   그래서 팩터리 함수를 사용해 이런 제약을 없앤다. 

9. 함수를 명령으로 바꾸기
   함수를 함수만을 위한 객체 안으로 캡슐화하면 더 유용해지는 상황이 있다. 이런 객체를 가리켜 '명령 객체 혹은
   단순히 ***명령***이라 한다.명렬 객체는 대부분은 메서드 하나로 구성되며, 이 메서드를 요청해 실행하는 것이 이 객체의 목적이다.

   명령은 평범한 함수 메커니즘보다 훨씬 유연하게 함수를 제어하고 표현할 수 있다.  명령은 되돌리기(undo) 같은 보조 연산을 제공할 수 있으며,
   수명주기를 더 정밀하게 제어하는 데 필요한 매개변수를 만들어주는 메서드도 제공할 수 있다. 상속과 훅을 이용해 사용자 맞춤형으로 만들 수도 있다.
   
    객체는 지원하지만 일급함수(first-class function)를 지원하지 않는 프로그래밍 언어를 사용할 때는 명령을 이용해 일급 함수의 기능 대부분을 흉내 낼 수 있다. 

    비슷하게, 중첩 함수를 지원하지 않는 언어에서도 메서드와 필드를 이용해 복잡한 함수를 잘게 쪼갤 수 있고, 이렇게 쪼갠 메서드들을 테스트와 디버깅에 직접 이용할 수 있다.

    이처럼 명령을 사용해 얻는 이점이 많으므로 함수를 명령으로 리팩터링할 채비를 갖춰야 할 것이다. 하지만, 유연성은 언제나 그렇듯 복잡성을 키우는 대가를 얻음을 잊지 말아야한다. 

   그래서 일급 함수와 명령 중 선택해야 한다면, 작자라면 95%는 일급 함수의 손을 들어준다.
   작자가 명령을 선택할 때는 명령보다 더 간단한 방식으로 얻을 수 없는 기능이 필요할 때뿐이다.

 10. 명령을 함수로 바꾸기
     명령 객체는 복잡한 연산을 다룰 수 있는 강력한 메커니즘을 제공한다. 
     구체적으로는, 큰 연산 하나를 여러 개의 작은 메소드로 쪼개고 필드를 이용해 쪼개진 메서드들끼리 정보를 공유할 수 있다. 또한 어떤 메소드를 호출하냐에 따라 다른 효과를 줄 수 있고 각 단계를 거치며 데이터를 조금씩 완성해갈 수도 있다.

     명령의 이런 능력은 공짜가 아니다. 명령이 그저 함수를 하나 호출해 정해진 일을 수행하는 용도로 주로쓰이거나, 로직이 크게 복잡하지 않다면 명령 객체는 장점보다 단점이 크니 평범한 함수로 바꿔주는게 낫다.

 11. 수정된 값 반환하기 
     데이터가 어떻게 수정되는지를 추적하는 일은 코드에서 이해하기 가장 어려운 부분 중 하나다. 
     특히, 같은 데이터 블록을 읽고 수정하는 코드가 여러 곳이라면 데이터가 수정되는 흐름과 코드의 흐름을 일치시키기가 상당히 어렵다. 그래서 데이터가 수정된다면 그 사실을 명확히 알려주어서, 어느 함수가 무슨 일을 하는지 쉽게 알 수 있게 하는 일이 대단히 중요하다.
      
      이 리팩터링은 값 하나를 계산한다는 분명한 목적이 있는 함수들에 가장 효과적이고, 반대로 값 여러 개를 갱신하는 함수에는 효과적이지 않다. 한편, 함수 옮기기의 준비 작업으로 적용하기 좋은 리팩터링이다.

 12. 오류 코드를 예외로 바꾸기
     예외는 프로그래밍 언어에서 제공하는 독립적인 오류 처리 메커니즘이다. 오류가 발견되면 예외를 던진다. 그러면 적절한 예외 핸들러를 찾을 때까지 콜스택을 타고 위로 전파된다.(핸들러를 찾지 못하면 보통은 단순할 정도로 극단적인 기본 동작이 수행된다.)

     예외는 정교한 메커니즘이지만 대다수의 다른 정교한 메커니즘과 같이 정확하게 사용할 때만 최고의 효과를 낸다. ***예외는 정확히 예상 밖의 동작일 때만 쓰여야 한다.*** 달리 말하면, 프로그램의 정상 동작 범주에 들지 않는 오류를 나타낼 때만 쓰여야 한다.

     괜찮은 경험 법칙이 하나 있다. 예외를 던지는 코드를 프로그램 종료 코드로 바꿔도 프로그램이 여전히 정상 동작할지를 따져보는 것이다.
     정상 동작하지 않을 것 같다면 예외를 사용하지 말라는 신호다. 예외 대신 오류를 검출하여 프로그램을 정상 흐름으로 되돌리게끔 처리해야 한다.

 13. 예외를 사전확인으로 바꾸기
     예외라는 개념은 프로그래밍 언어의 발전에 의미 있는 한걸음이다. 오류코드를 연쇄적으로 전파하던 긴 코드를 예외로 바꿔 깔끔히 제거할 수 있게 되었으니 말이다. 하지만 좋은 것들은 늘 그렇듯, 예외도 과용되곤한다. 예외는 '뜻밖의 오류'라는, 말 그대로 예외적으로 동작할 때만 쓰여야 한다. 함수 수행 시 문제가 될 수 있는 조건을 함수 호출 전에 검사할 수 있다면, 예외를 던지는 대신 호출하는 곳에서 조건을 검사하도록 해야 한다.


   --- 2020.11.11 ---