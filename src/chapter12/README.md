# 12장 정리
## 상속 다루기
   객체 지향 프로그래밍에서 가장 유용한 특성인 상속을 다룬다. 
   다른 강력한 메커니즘처럼 이 역시 아주 유용한 동시에 오용하기 쉽다.

1. 메서드 올리기
   중복 코드 제거는 중요하다. 
   중복된 두 메서드가 당장은 문제없이 동작할지라도 미래에는 벌레가 꼬이는 음식물 쓰레기로 전락할 수 있다.
   메서드 올리기를 적용하기 가장 쉬운 상황은 메소드들의 본문 코드가 똑같은 때다.
   반면, 가장 이상하고 복잡한 상황은 해당 메서드의 본문에서 참조하는 필드들이 서브클래스에만 있는 경우이다.
   이때는 필드들 먼저 슈퍼클래스로 올린 후에 메서드를 올려야 한다.
   두 메서드의 전체 흐름은 비슷하지만 세부 내용이 다르다면 템플릿 메서드 만들기를 고려야보자.

2. 필드 올리기
   서브클래스들이 독립적으로 개발되었거나 뒤늦게 하나의 계층구조로 리팩터링된 경우라면 일부 기능이 중복되어 있을 때가 왕왕있다.
   각 필드를 분석하고 분석 결과 필드들이 비슷한 방식으로 쓰인다고 판단되면 슈퍼클래스로 끌어올리자
   
   이렇게 하면 두 가지 중복을 줄일 수 있다.
   1. 데이터 중복 선언을 없앨 수 있다.
   2. 해당 필드를 사용하는 동작을 서브클래스에서 슈퍼클래스로 옮길 수 있다.

3. 생성자 본문 올리기
   생성자는 일반 메서드와는 많이 달라서 까다롭다.
   작자는 서브클래스들에서 기능이 같은 메서드들을 발견하면 함수 추출하기와 메서드 올리기를 차례로 적용하여 말끔히 슈퍼클래스로 옮기곤 한다.
   생성자는 할 수 있는 일과 호출 순서에 제약이 있기 때문에 조금 다른 식으로 접근해야 한다.

4. 메서드 내리기
   특정 서브클래스가 정확히 무엇인지를 호출자가 알고 있을 때 적용
   그렇지 못한 상황이라면 서브클래스에 따라 다르게 동작하는 슈퍼클래스의 기만적인 조건부 로직을 다형성으로 바꿔야 한다.

5. 필드 내리기
   서브클래스 하나(혹은 소수)에서만 사용하는 필드는 해당 서브클래스들로 옮긴다.

6. 타입 코드를 서브클래스로 바꾸기
   소프트웨어 시스템에서는 비슷한 대상들을 특성에 따라 구분해야할 때, 다루는 수간으로는 타입코드 필드가있다.
   타입 코드는 프로그래밍 언어에 따라 열거형이나 심볼, 문자열, 숫자 등으로 표현하며, 외부 서비스가 제공하는 데이터를 다루려 할 때 딸려오는 일이 흔하다.
   
   타입 코드만으로 부족할때 서비클래스를 사용한다. 서브 클래스의 갑작스러운 두가지 매력
   1. 조건에 따라 다르게 동작하도록 해주는 다형성을 제공.
      타입 코드에 따라 동작이 달라져야 하는 람구가 여러 개일 때 특히 유용하다
   2. 특정 타입에서만 의미가 있는 값을 사용하는 필드나 메서드가 있을 때 발현된다.

   이번 리팩터링의 대상은 클래스에 직접 적용할지, 아니면 타입 코드 자체에 적용할지를 고민해야 한다.
   예컨대 전자 방식이라면 직원의 하위 타입인 엔지니어를 만들것이다. 반면 후자는 직원에게 직원 유형 '속성'을 부여하고,
   이 속성을 클래스로 정의해 엔지니어 속성과 관리자 속성 같은 서브클래스를 만드는 식이다.

7. 서브클래스 제거하기
   더 이상 쓰이지 않는 서브클래스와 마주하는 프로그래머는 가치 없는 것을 이해하느라 에너지를 낭비할 것이다.

8. 슈퍼클래스 추출하기
   상속은 프로그램이 성장하면서 깨우쳐가기 도히며, 슈퍼클래스로 끌어올리고 싶은 공통 요소를 찾았을 때 수행하는 사례가 잦다.
   슈퍼클래스 추출하기의 대안으로는 클래스 추출하기가 있다.

9. 계층 합치기
   계층구조도 진화하면서 어떤 클래스와 그 부모가 너무 비슷해져서 더는 독립적으로 존재해야 할 이유가 사라지는 경우가 생기기도 한다.

10. 서브클래스를 위임으로 바꾸기
   (단일 상속 기준) 단점은 단일 상속이라 하나의 클래스만 상속받을 수 있다는 것이다. 또, 상속은 클래스들의 관계를 아주 긴밀하게 결합한다.

   위임(Delegate)은 이 두가지 문제를 모두 해결해 준다.
   유명한 원칙이 하나 있다
   "(클래스) 상속보다는 (객쳬) 컴포지션을 사용하라!"
   여기서 컴포지션은 사실상 위임과 같은 말이다. 

   디자인 패턴에 익숙한 사람이라면 이 리팩터링을 
   '서브클래스를 상태 패턴이나 전략 패턴으로 대체'한다고 생각하면 도움이 될 것이다.

11. 슈퍼클래스를 위임으로 바꾸기
   상속을 잘못 적용한 예로 자바의 스택 클래스가 유명하다.
   자바의 스택은 리스트를 상속하고 있는데, 데이터를 저장하고 조작하는 리스트의 기능을 재활용하겠다는 생각이 초래한 결과다.
   리스트의 연산 중 스택에는 적용되지 않는 게 많음에도 그 모든 연산이 스택 인터페이스에 그대로 도출되는 문제가 있다.!
   이보다 스택에서 리스트 객체를 필드에 저장해두고 필요한 기능만 위임했다면 더 멋졌을 것이다.

   끄으으으읕!
